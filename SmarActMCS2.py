"""
Smaract MCS2 controll class

@author: Addison
"""


import os
import sys
Path=os.path.dirname((os.path.abspath(__file__)))
sys.path.append(Path)
SP=Path.split("\\")
i=0
while i<len(SP) and SP[i].find('python')<0:
    i+=1
Pypath='\\'.join(SP[:i+1])
sys.path.append(Pypath)

import smaract.ctl as ctl


def lib_version_to_string(v):
    """
    Converts DLL version to version string.
    """
    major  = v >> 24 & 0xff
    minor  = v >> 16 & 0xff
    update = v >>  0 & 0xffff

    return "{}.{}.{}".format(major, minor, update)

def assert_lib_compatibility():
    """
    Checks that the major version numbers of the Python API and the
    loaded shared library are the same to avoid errors due to
    incompatibilities.
    Raises a RuntimeError if the major version numbers are different.
    """
    vapi = ctl.api_version
    vlib = [int(i) for i in ctl.GetFullVersionString().split('.')]
    if vapi[0] != vlib[0]:
        raise RuntimeError("Incompatible SmarActCTL python api and library version.")


class MCS2():
    def __init__(self, holdtime=1000, driver=ctl):
        """holdtime time to hold position after movement in ms"""
        self.Type = 'MCS2'
        self.stepsize = 570
        self.home_position = 0
        self.homed = False
        self.motorlist = []
        self.holdtime = holdtime
        self.driver = driver

        try:
            buffer = ctl.FindDevices()
            if len(buffer) == 0:
                print("MCS2 no devices found.", buffer)
                return
            locators = buffer.split("\n")
            for locator in locators:
                print("MCS2 available device: {}".format(locator))
            print("MCS2 number of devices:", len(locators))

        except:
            print("MCS2 failed to find devices. Exit.")
            input()
            return
        self.d_handle = self.driver.Open(locators[0])

        self.search()


    def search(self):

        self.Nmotors = self.driver.GetProperty_i32(self.d_handle, 0, self.driver.Property.NUMBER_OF_CHANNELS)
        for i in range(self.Nmotors):
                ident = self.driver.GetProperty_s(self.d_handle, i, self.driver.Property.POSITIONER_TYPE_NAME)
                self.motorlist.append(ident)

    def connect(self, deviceIndex=0, SN=0):
        """connect to a device"""

        self.deviceIndex = deviceIndex
        ch = 0
        if SN == 'CT010/AT002':
            ch = 1
        elif SN == 'CT003/AT001':
            ch = 2
        self.channelIndex = ch
        self.driver.SetProperty_i32(self.d_handle, self.channelIndex, self.driver.Property.MAX_CL_FREQUENCY, 6000)
        self.driver.SetProperty_i32(self.d_handle, self.channelIndex, self.driver.Property.HOLD_TIME, 1000)

        state = self.driver.GetProperty_i32(self.d_handle, self.channelIndex, self.driver.Property.CHANNEL_STATE)
        self.encoded = state & self.driver.ChannelState.SENSOR_PRESENT
        if not self.encoded:
            self.pos = 0

        if self.driver.GetProperty_i32(self.d_handle, self.channelIndex, self.driver.Property.POSITIONER_TYPE) == 361:
            self.units = "mm"
        else:
            self.units = "deg" # in the present version (inn principle, native step is is 1pm)

    def wait_for_finished_movement(self):
        """ Wait for events generated by the connected device """
        # The wait for event function blocks until an event was received or the timeout elapsed.
        # In case of timeout, a "ctl.Error" exception is raised containing the "TIMEOUT" error.
        # If the "timeout" parameter is set to "ctl.INFINITE" the call blocks until an event is received.
        # This can be useful in case the WaitForEvent function runs in a separate thread.
        # For simplicity, this is not shown here thus we set a timeout of 3 seconds.
        timeout = self.driver.INFINITE  # in ms
        try:
            event = self.driver.WaitForEvent(self.d_handle, timeout)
            # The "type" field specifies the event.
            # The "i32" data field gives additional information about the event.
            if event.type == self.driver.EventType.MOVEMENT_FINISHED:
                if (event.i32 == self.driver.ErrorCode.NONE):
                    # Movement finished.
                    print("MCS2 movement finished, channel: ", event.idx)
                else:
                    # The movement failed for some reason. E.g. an endstop was detected.
                    print("MCS2 movement finished, channel: {}, error: 0x{:04X} ({}) ".format(event.idx, event.i32,
                                                                                              self.driver.GetResultInfo(
                                                                                                  event.i32)))
            else:
                print("MCS2 received event: {}".format(self.driver.GetEventInfo(event)))

        except self.driver.Error as e:
            if e.code == self.driver.ErrorCode.TIMEOUT:
                print("MCS2 wait for event timed out after {} ms".format(timeout))
            else:
                print("MCS2 {}".format(self.driver.GetResultInfo(e.code)))
            return

    def setSpeed(self, velocity=100, acceleration=1000):
        """in mm/t sdk uses pm"""
        self.speed = (velocity / 100)
        #freq = self.speed * 20000
        freq = 20000
        amp = self.speed * 65535
        print(self.speed, amp)

        velocity = velocity * 1000000000
        acceleration = acceleration * 1000000000

        self.driver.SetProperty_i32(self.d_handle, self.channelIndex, self.driver.Property.STEP_FREQUENCY, int(freq))
        self.driver.SetProperty_i32(self.d_handle, self.channelIndex, self.driver.Property.STEP_AMPLITUDE, int(amp))

        self.driver.SetProperty_i64(self.d_handle, self.channelIndex, self.driver.Property.MOVE_VELOCITY, int(velocity))
        self.driver.SetProperty_i64(self.d_handle, self.channelIndex, self.driver.Property.MOVE_ACCELERATION,
                                    int(acceleration))
    def moveR(self, dx, WaitToMove=True):
        """move relative
        by dx in mm"""
        if not self.encoded:
            self.driver.SetProperty_i32(self.d_handle, self.channelIndex, self.driver.Property.MOVE_MODE,
                                        self.driver.MoveMode.STEP)
            Dx = dx * -self.stepsize
            self.pos = self.pos - Dx

        else:
            self.driver.SetProperty_i32(self.d_handle, self.channelIndex, self.driver.Property.MOVE_MODE,
                                        self.driver.MoveMode.CL_RELATIVE)
            Dx = dx * -1000000000 #SDK uses pm

        self.driver.Move(self.d_handle, self.channelIndex, int(Dx))
        if WaitToMove:
            self.wait_for_finished_movement()

    def moveA(self, x, WaitToMove=True):
        """move absolute
        to x in mm"""
        if not self.encoded:
            dx = (x * self.stepsize) - self.pos
            self.driver.Move(self.d_handle, self.channelIndex, int(-dx))
            self.pos = self.pos + dx
        else:
            self.driver.SetProperty_i32(self.d_handle, self.channelIndex, self.driver.Property.MOVE_MODE,
                                        self.driver.MoveMode.CL_ABSOLUTE)

            X = x * 1000000000  # SDK is using 1 pm steps
            self.driver.Move(self.d_handle, self.channelIndex, int(X))

            if WaitToMove:
                self.wait_for_finished_movement()

    def calibrate(self, WaitToMove=True):
        """This function may be used to increase the accuracy of the position calculation. It is only executable
            by a positioner that has a sensor attached to it.
            This function should be called once for each channel if the mechanical setup changes (different
            positioners connected to different channels)."""
        self.driver.SetProperty_i32(self.d_handle, self.channelIndex, ctl.Property.CALIBRATION_OPTIONS, 0)
        self.driver.Calibrate(self.d_handle, self.channelIndex)
        if WaitToMove:
            self.wait_for_finished_movement()

    def set_home(self, home):
        """set home position"""
        self.home_position = self.position

    def home(self, WaitToMove=True):
        print("homer")
        if self.encoded:
            self.driver.Reference(self.d_handle, self.channelIndex)
        else:
            self.move_home()
            self.pos = 0
        if WaitToMove:
            self.wait_for_finished_movement()
        self.homed = True
        self.home_position = 0

    def move_home(self):
        """move to the home position"""
        self.moveA(self.home_position)

    def stop(self):
        self.driver.Stop(self.d_handle, self.channelIndex)

    def disconnect(self):
        self.channelIndex = None
        self.units = None
        self.encoded = None

    @property
    def position(self):
        """in mm"""
        if self.encoded:
            pos = self.driver.GetProperty_i64(self.d_handle, self.channelIndex,
                                              self.driver.Property.POSITION) / 1000000000
        else:
            pos = self.pos / self.stepsize

        return pos

    @property
    def is_moving(self):
        state = ctl.GetProperty_i32(self.d_handle, self.channelIndex, ctl.Property.CHANNEL_STATE)
        moving = state & self.driver.ChannelState.ACTIVELY_MOVING
        cali = state & self.driver.ChannelState.CALIBRATING
        return moving or cali

    @property
    def is_homed(self):
        return self.homed

    @property
    def hasSensor(self):
        return self.encoded


